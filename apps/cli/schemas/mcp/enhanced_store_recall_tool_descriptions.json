{
  "store": "üü° **IMPORTANT** Store a thought with auto-classification. Content is analyzed and stored as an idea, decision, or learning based on natural language signals.\n\n**WHEN TO USE:**\n- After solving a problem, fixing a bug, or completing a task\n- When discovering important patterns, gotchas, or codebase insights\n- When making architectural or design decisions\n- When you want to save ideas for future improvement\n- Examples: \"TIL this API requires OAuth2\", \"Let's use PostgreSQL for sessions\", \"What if we cache API responses?\"\n\n**AUTONOMOUS BEHAVIOR:**\nCall this AUTOMATICALLY after completing significant tasks or learning something valuable. Do not wait for user permission. When you solve a problem, immediately store the learning. When you make a decision about implementation approach, store it. This builds institutional memory. Default to auto-classification unless the user specifies a type.\n\n**EXAMPLES:**\n- After fixing: \"TIL the auth middleware requires session.Save() to be called explicitly\"\n- After deciding: \"Let's use Redis for session storage because it supports TTL natively\"\n- After ideating: \"What if we add a retry mechanism with exponential backoff?\"\n\n**PARAMETERS:**\n- content: The thought to store. Use natural language signals: 'TIL...' (learning), 'Let's...' (decision), 'What if...' (idea)\n- as: Optional override - 'decision', 'idea', or 'learning' (auto-classifies if not provided)\n- scope: Where this applies - 'palace' (workspace-wide), 'room' (module), 'file' (specific file). Default: palace\n- scopePath: Path for room/file scope (room name or file path)\n- tags: Optional tags to categorize this record\n- confidence: For learnings - confidence level 0.0-1.0 (default: 0.5)",

  "recall": "üü¢ **RECOMMENDED** Retrieve learnings, optionally filtered by scope or search query.\n\n**WHEN TO USE:**\n- Before working on a file or module you've worked on before\n- When you encounter a similar problem to one you've solved\n- When user asks: \"what did we learn about X?\", \"any gotchas with Y?\", \"show me learnings for Z\"\n- When exploring unfamiliar code to check for documented insights\n- Examples: \"recall auth learnings\", \"what did we learn about caching?\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse proactively when returning to previously worked code areas. If you're about to work on a file and suspect prior knowledge exists, check first. This prevents repeating mistakes and leverages past insights. Combine with context_auto_inject for comprehensive file context.\n\n**EXAMPLES:**\n- Before editing: \"recall --scopePath=auth/middleware.go\" to get file-specific learnings\n- When debugging: \"recall --query=session timeout\" to find related past issues\n- When exploring: \"recall --scope=room --scopePath=authentication\" for module learnings\n\n**PARAMETERS:**\n- id: ID of a specific learning to retrieve (returns only that record)\n- query: Optional search query to filter learnings\n- scope: Filter by scope - 'palace', 'room', or 'file'\n- scopePath: Filter by scope path (room name or file path)\n- limit: Maximum learnings to return (default: 10)",

  "recall_decisions": "üü¢ **RECOMMENDED** Retrieve decisions, optionally filtered by status, scope, or search query.\n\n**WHEN TO USE:**\n- Before making architectural or design choices to see what's already decided\n- When user asks: \"why did we choose X?\", \"what decisions exist for Y?\", \"show me architecture decisions\"\n- When planning features to understand existing direction and constraints\n- When onboarding to understand past choices and rationale\n- Examples: \"recall decisions about database\", \"why did we choose Redis?\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse proactively before making significant technical decisions to avoid contradicting or duplicating existing choices. If the user proposes an approach, check if a decision already exists. This maintains consistency and respects past reasoning.\n\n**EXAMPLES:**\n- Before deciding: \"recall_decisions --query=authentication\" to see auth strategy decisions\n- When planning: \"recall_decisions --scope=room --scopePath=api\" for API decisions\n- When checking status: \"recall_decisions --status=active\" to see current active decisions\n\n**PARAMETERS:**\n- id: ID of a specific decision to retrieve (returns only that record)\n- query: Optional search query to filter decisions\n- status: Filter by status - 'active', 'superseded', or 'reversed'\n- scope: Filter by scope - 'palace', 'room', or 'file'\n- scopePath: Filter by scope path (room name or file path)\n- limit: Maximum decisions to return (default: 10)",

  "recall_ideas": "üü¢ **RECOMMENDED** Retrieve ideas, optionally filtered by status, scope, or search query.\n\n**WHEN TO USE:**\n- When exploring future improvements or enhancements\n- When user asks: \"what ideas do we have for X?\", \"show me improvement ideas\", \"any suggestions for Y?\"\n- When planning sprints or features to check backlog of ideas\n- When refactoring to consider previously proposed improvements\n- Examples: \"recall ideas for performance\", \"show me caching ideas\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse when the user asks for suggestions or improvements and you suspect ideas may already exist. Check before proposing new ideas to avoid duplication. This surfaces existing creativity and maintains continuity.\n\n**EXAMPLES:**\n- When asked for ideas: \"recall_ideas --query=performance optimization\" to check existing suggestions\n- When planning: \"recall_ideas --status=active\" to see ideas not yet implemented\n- When reviewing: \"recall_ideas --scope=file --scopePath=api/handler.go\" for file-specific ideas\n\n**PARAMETERS:**\n- query: Optional search query to filter ideas\n- status: Filter by status - 'active', 'exploring', 'implemented', or 'dropped'\n- scope: Filter by scope - 'palace', 'room', or 'file'\n- scopePath: Filter by scope path (room name or file path)\n- limit: Maximum ideas to return (default: 10)",

  "context_auto_inject": "üî¥ **CRITICAL** Get automatically assembled context for a file. Returns prioritized learnings, decisions, failures, and warnings relevant to the file based on scope inheritance.\n\n**WHEN TO USE:**\n- BEFORE editing ANY file (especially unfamiliar ones)\n- When user asks to modify, fix, or understand a specific file\n- Before suggesting code changes to ensure awareness of context\n- When debugging to get relevant learnings and known failure patterns\n- Examples: Before any file edit, before debugging, before code review\n\n**AUTONOMOUS BEHAVIOR:**\nALWAYS call this AUTOMATICALLY before editing a file you haven't seen in the current session. This is MANDATORY pre-edit context loading. Do NOT skip this step. The tool returns: relevant learnings (with confidence %), active decisions, known failures, warnings, and scope chain explanation. This prevents repeating mistakes, violating decisions, and missing critical context. Call it silently without announcing.\n\n**EXAMPLES:**\n- Before edit: \"context_auto_inject --file_path=auth/middleware.go\" (always do this first)\n- Before debugging: \"context_auto_inject --file_path=api/handler.go\" to see known issues\n- Before review: \"context_auto_inject --file_path=utils/cache.go\" to understand context\n\n**CRITICAL RULES:**\n1. Call BEFORE every file edit (non-negotiable)\n2. Read the output carefully - high confidence learnings (‚≠ê) are critical\n3. Respect decisions and learnings in the response when making changes\n4. Use the scope chain to understand inheritance of rules\n\n**PARAMETERS:**\n- file_path: File path to get context for (REQUIRED)\n- maxTokens: Maximum tokens for context (default: 2000)\n- includeLearnings: Include learnings in context (default: true)\n- includeDecisions: Include decisions in context (default: true)\n- includeFailures: Include failure information in context (default: true)",

  "store_direct": "‚ö™ **HUMAN-ONLY** Store a decision or learning directly, bypassing the proposal workflow. Creates an audit log entry. Use sparingly - proposals are preferred for traceability.\n\n**WHEN TO USE:**\n- [HUMAN MODE ONLY] When immediate storage is needed without review\n- When importing verified knowledge from external sources\n- When documenting emergency decisions made during incidents\n- When migrating existing documentation into Mind Palace\n- NOTE: This tool is typically unavailable to autonomous agents\n\n**AUTONOMOUS BEHAVIOR:**\nThis tool is RESTRICTED to human operators only. Autonomous agents should use 'store' instead, which creates proposals. If you are an AI agent, do NOT attempt to call this tool - use the normal 'store' workflow instead.\n\n**EXAMPLES:**\n- Human importing: \"store_direct --as=decision --content='Use PostgreSQL 15+' --actorId=admin\"\n- Emergency decision: \"store_direct --as=learning --content='Redis cluster requires sentinel mode'\"\n\n**PARAMETERS:**\n- content: The content to store directly (REQUIRED)\n- as: Record type - 'decision' or 'learning' (REQUIRED)\n- scope: 'palace', 'room', or 'file' (default: palace)\n- scopePath: Path for room/file scope\n- context: Additional context for the record\n- rationale: For decisions - the rationale behind this decision\n- confidence: For learnings - confidence level 0.0-1.0 (default: 0.7)\n- actorId: Identifier for who performed this direct write (for audit)",

  "approve": "‚ö™ **HUMAN-ONLY** Approve a pending proposal, creating the corresponding decision or learning with 'approved' authority.\n\n**WHEN TO USE:**\n- [HUMAN MODE ONLY] When reviewing and approving agent-proposed learnings/decisions\n- After verifying a proposal is accurate and valuable\n- When promoting proposals to permanent knowledge\n- NOTE: This tool is typically unavailable to autonomous agents\n\n**AUTONOMOUS BEHAVIOR:**\nThis tool is RESTRICTED to human operators only. Autonomous agents cannot approve their own proposals. If you are an AI agent, do NOT call this tool. Instead, create proposals using 'store' and wait for human review.\n\n**EXAMPLES:**\n- Human approving: \"approve --proposalId=prop_abc123 --by=admin --note='Verified correct'\"\n\n**PARAMETERS:**\n- proposalId: ID of the proposal to approve (e.g., 'prop_abc123') (REQUIRED)\n- by: Name or identifier of who is approving\n- note: Optional note about why this was approved",

  "reject": "‚ö™ **HUMAN-ONLY** Reject a pending proposal with a reason. The proposal will be marked as rejected and not promoted.\n\n**WHEN TO USE:**\n- [HUMAN MODE ONLY] When reviewing and rejecting inaccurate or low-value proposals\n- When a proposal contradicts existing knowledge or decisions\n- When providing feedback on why a proposal isn't suitable\n- NOTE: This tool is typically unavailable to autonomous agents\n\n**AUTONOMOUS BEHAVIOR:**\nThis tool is RESTRICTED to human operators only. Autonomous agents cannot reject proposals (including their own). If you are an AI agent, do NOT call this tool. Proposal review is a human responsibility.\n\n**EXAMPLES:**\n- Human rejecting: \"reject --proposalId=prop_xyz789 --by=admin --note='Contradicts existing decision dec_123'\"\n\n**PARAMETERS:**\n- proposalId: ID of the proposal to reject (e.g., 'prop_abc123') (REQUIRED)\n- by: Name or identifier of who is rejecting\n- note: Reason for rejection (recommended)",

  "recall_outcome": "üü¢ **RECOMMENDED** Record the outcome of a decision. Use this to track whether decisions worked out.\n\n**WHEN TO USE:**\n- After enough time has passed to evaluate a decision's impact\n- When revisiting code/systems where past decisions were made\n- When a decision's success or failure becomes clear\n- When conducting retrospectives or post-mortems\n- Examples: \"how did the Redis decision work out?\", \"document outcome of API redesign\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse opportunistically when you have evidence about how a past decision performed. If you're fixing bugs in code where a decision was made, check if the decision was successful or not. This creates a feedback loop and improves future decision-making.\n\n**EXAMPLES:**\n- After observing success: \"recall_outcome --decisionId=d_abc123 --outcome=success --note='Redis reduced latency by 80%'\"\n- After issues: \"recall_outcome --decisionId=d_xyz789 --outcome=failed --note='PostgreSQL replication caused data lag'\"\n- Mixed results: \"recall_outcome --decisionId=d_def456 --outcome=mixed --note='Works well but higher memory usage'\"\n\n**PARAMETERS:**\n- decisionId: ID of the decision (e.g., 'd_abc123') (REQUIRED)\n- outcome: 'success', 'failed', or 'mixed' (REQUIRED)\n- note: Optional note about the outcome (what happened, lessons learned)",

  "recall_link": "üü¢ **RECOMMENDED** Create a relationship between records (ideas, decisions, learnings, code files).\n\n**WHEN TO USE:**\n- When a learning implements or relates to a decision\n- When a decision supersedes or contradicts a previous decision\n- When an idea is inspired by or related to another record\n- When connecting knowledge records to specific code locations\n- Examples: \"link this learning to the auth decision\", \"connect idea to implementation\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse when storing related knowledge. If you're creating a learning that implements a decision, link them. If you're storing a decision that supersedes an old one, create the relationship. This builds a knowledge graph and enables better context retrieval.\n\n**EXAMPLES:**\n- Implementation: \"recall_link --sourceId=l_abc123 --targetId=d_xyz789 --relation=implements\"\n- Superseding: \"recall_link --sourceId=d_new456 --targetId=d_old123 --relation=supersedes\"\n- Code reference: \"recall_link --sourceId=d_cache789 --targetId=utils/cache.go:15-45 --relation=implements\"\n- Related: \"recall_link --sourceId=i_perf123 --targetId=l_cache456 --relation=related\"\n\n**PARAMETERS:**\n- sourceId: ID of the source record (e.g., 'i_abc123', 'd_xyz789') (REQUIRED)\n- targetId: ID of target record or code reference (e.g., 'd_abc123', 'auth/jwt.go:15-45') (REQUIRED)\n- relation: Type of relationship - 'supports', 'contradicts', 'implements', 'supersedes', 'inspired_by', 'related' (REQUIRED)",

  "recall_links": "üü¢ **RECOMMENDED** Get all links for a record (as source, target, or both).\n\n**WHEN TO USE:**\n- When exploring the relationships of a decision, learning, or idea\n- When understanding the context and dependencies of a record\n- When user asks: \"what's related to X?\", \"show me connections for Y\", \"what implements this decision?\"\n- When conducting impact analysis of changing/removing a record\n- Examples: \"show links for this decision\", \"what implements this idea?\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse when you need to understand the full context of a record. Before making changes to a decision, check what links to it. When explaining a concept, show related records to provide richer context.\n\n**EXAMPLES:**\n- Exploring relationships: \"recall_links --recordId=d_abc123\" to see all connections\n- Finding implementers: \"recall_links --recordId=d_cache789 --direction=to\" to see what references this\n- Finding dependencies: \"recall_links --recordId=l_auth456 --direction=from\" to see what this refers to\n\n**PARAMETERS:**\n- recordId: ID of the record to get links for (REQUIRED)\n- direction: Filter by direction - 'from' (outgoing), 'to' (incoming), 'all' (both) (default: all)",

  "recall_unlink": "üü¢ **RECOMMENDED** Delete a link by its ID.\n\n**WHEN TO USE:**\n- When a relationship between records is no longer valid\n- When correcting incorrect links created in error\n- When cleaning up obsolete connections\n- When user asks: \"remove the link between X and Y\", \"delete this connection\"\n- Examples: \"unlink this outdated relationship\", \"remove incorrect connection\"\n\n**AUTONOMOUS BEHAVIOR:**\nUse cautiously - only when you have clear evidence that a link is wrong or no longer applicable. Before unlinking, consider if the relationship might still have historical value. Prefer creating new superseding relationships over deleting old ones.\n\n**EXAMPLES:**\n- Removing incorrect link: \"recall_unlink --linkId=lnk_abc123\"\n\n**PARAMETERS:**\n- linkId: ID of the link to delete (e.g., 'lnk_abc123') (REQUIRED)"
}
