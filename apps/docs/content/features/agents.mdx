# MCP Integration

Mind Palace treats AI agents as first-class consumers. Schemas are contracts, not suggestions.

---

## Two Integration Modes

| Mode | Best For | How |
|------|----------|-----|
| **MCP** | Interactive agents (Claude, Cursor) | `palace serve` |
| **Context Pack** | Batch/CLI agents | `palace context "goal"` |

---

## MCP Integration

### Setup (Claude Desktop)

Add to `~/Library/Application Support/Claude/claude_desktop_config.json`:

```json
{
  "mcpServers": {
    "mind-palace": {
      "command": "palace",
      "args": ["serve", "--root", "/path/to/project"]
    }
  }
}
```

### Setup (Cursor)

```json
{
  "mcp.servers": {
    "mind-palace": {
      "command": "palace",
      "args": ["serve", "--root", "${workspaceFolder}"]
    }
  }
}
```

### Available Tools

| Tool | Parameters | Returns |
|------|------------|---------|
| `search_mind_palace` | `query`, `limit?`, `room?` | Ranked results by Room |
| `list_rooms` | - | Room names + entry points |
| `get_context` | `goal`, `diff?` | Context pack for a task |
| `get_graph` | `symbol`, `callers?`, `callees?` | Call graph relationships |
| `start_session` | `agentType`, `goal?` | Session ID |
| `end_session` | `sessionId` | Confirmation |
| `log_activity` | `sessionId`, `kind`, `target`, `outcome?` | Activity ID |
| `add_learning` | `content`, `scope?`, `scopePath?`, `confidence?` | Learning ID |
| `get_learnings` | `query?`, `scope?`, `scopePath?` | Matching learnings |
| `get_file_intel` | `path` | File intelligence data |
| `check_conflict` | `path` | Conflict detection result |
| `get_active_agents` | - | List of active agents |

### Available Resources

| URI | Returns |
|-----|---------|
| `palace://files/{path}` | File content |
| `palace://rooms/{name}` | Room manifest JSON |

### Why MCP?

- **Targeted queries** - Search, don't dump
- **Room-aware** - Results grouped by Room
- **Entry point boosting** - Important files surface first
- **Live index** - No stale context packs
- **Session tracking** - Monitor agent activity
- **Learning capture** - Store and retrieve knowledge

---

## Context Pack Integration

For agents that can't use MCP:

```sh
palace context "Fix auth bug"
# Provide .palace/outputs/context-pack.json to agent
```

The context pack contains:
- Goal and scope
- Referenced files with content
- Room context
- Provenance (scan ID, timestamp)
- Relevant learnings

---

## Agent Rules

### Must Read

| File | Contains |
|------|----------|
| `palace.jsonc` | Project config, guardrails |
| `rooms/*.jsonc` | Entry points, scope |
| `context-pack.json` | Current goal, findings |

### Must Not Touch

| Path | Reason |
|------|--------|
| `.palace/index/*` | Generated by CLI |
| `.palace/outputs/*` | Generated by CLI |
| Files matching guardrails | Protected |

### Scope Discipline

```
If scope is "diff":
  Only modify files in the diff
  Request broader scope explicitly if needed

If scope is "full":
  Still respect guardrails
  Prefer Room-scoped changes
```

---

## Verification Loop

```
Agent proposes → Human reviews → Save → Observer checks → Fresh ✓ or Stale ✗
```

### With Observer (VS Code)

1. Agent queries via MCP or reads context pack
2. Agent proposes changes
3. Human saves files
4. Observer runs `palace check`
5. HUD shows Fresh (green) or Stale (red)
6. If stale, auto-heal runs `scan`

### Without Observer (CLI)

```sh
# After agent changes
palace check --fast
# If stale:
palace scan && palace context "next goal"
```

---

## Handling Staleness

When `palace check` fails:

```
Agent: "Index is stale. Please run `palace scan` or approve auto-heal."
```

Never proceed with stale context. Request refresh.

---

## Change Signal

For diff-scoped work:

```sh
palace ci signal --diff HEAD~1..HEAD
palace context "fix bug" --diff HEAD~1..HEAD
```

Agents should:
1. Check if `change-signal.json` exists
2. Use its file list to scope work
3. Treat deleted files as non-editable

---

## Session Memory Integration

Track agent work with sessions:

```json
{
  "tool": "start_session",
  "arguments": {
    "agentType": "claude-code",
    "goal": "Implement user authentication"
  }
}
```

During work, log activities:

```json
{
  "tool": "log_activity",
  "arguments": {
    "sessionId": "session-123",
    "kind": "file_edit",
    "target": "src/auth/login.go",
    "outcome": "success"
  }
}
```

Capture learnings:

```json
{
  "tool": "add_learning",
  "arguments": {
    "content": "This module requires null checks",
    "scope": "file",
    "scopePath": "src/auth/login.go",
    "confidence": 0.85
  }
}
```

Before editing, check for conflicts:

```json
{
  "tool": "check_conflict",
  "arguments": {
    "path": "src/auth/login.go"
  }
}
```

---

## Best Practices

1. **Start a session** - Always begin with `start_session` to enable tracking
2. **Log activities** - Record reads, edits, and commands for file intelligence
3. **Capture learnings** - Store patterns and heuristics discovered during work
4. **Check for conflicts** - Before editing, verify no other agent is working on the file
5. **End sessions properly** - Call `end_session` when done
6. **Respect guardrails** - Never touch protected files
7. **Honor scope** - Stay within the requested scope (diff or full)
