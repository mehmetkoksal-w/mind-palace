---
title: Autonomous Agent Guide
description: Complete guide for AI agents to use Mind Palace autonomously
---

# Autonomous Agent Guide

Mind Palace is designed for **deterministic, autonomous agent workflows**. This guide shows AI agents how to use Mind Palace automatically without manual intervention.

## Philosophy: Why Mind Palace for Agents?

Modern AI agents work across large codebases without your institutional memory. Mind Palace provides:

1. **Session Management**: Coordinate multiple agents, prevent conflicts
2. **Deterministic Context**: No embeddings required - schema-validated, queryable knowledge
3. **File Intelligence**: Know what breaks, what's hot, what decisions apply to each file
4. **Failure Memory**: Learn from past mistakes automatically
5. **Autonomous Workflows**: Agents know WHEN to use tools via priority system

## Quick Start: Single-Call Initialization

Every agent task starts with one call:

```typescript
// 1. Initialize with full context (RECOMMENDED - ONE CALL DOES IT ALL)
const init = await session_init({
  agent_name: "cursor",
  task: "Add authentication"
})
// Returns: session ID, workspace briefing, project structure, pending handoffs

// 2. Get file context before editing
const fileContext = await context_auto_inject({file_path: "auth/jwt.ts"})
// fileContext includes: learnings, decisions, failures, hotspots

// 3. End session when done
await session_end({outcome: "success", summary: "Added JWT refresh tokens"})
```

That's it. `session_init` combines session_start + brief + explore_rooms into a single call and shows any pending handoffs waiting for you.

## Priority System

All 77+ Mind Palace tools have priority indicators:

- üî¥ **CRITICAL**: Must do these (session_init, context_auto_inject, session_end)
- üü° **IMPORTANT**: Should do these (store, session_log, session_conflict, handoff_create)
- üü¢ **RECOMMENDED**: Optional but valuable (recall, explore, analytics_health, context_focus)
- ‚ö™ **ADMIN**: Human-mode only (approve, reject, store_direct)

Agents should **always** execute CRITICAL tools, **usually** execute IMPORTANT tools, and **conditionally** use RECOMMENDED tools.

## Complete Autonomous Workflow

Here's a full example for adding a feature:

### 1. Session Initialize (üî¥ CRITICAL - THE FIRST CALL)

```typescript
const init = await session_init({
  agent_name: "cursor",
  task: "Add JWT refresh token support"
})
```

**Returns:**
- Session ID (use for all subsequent calls)
- Active agents and their current work
- Workspace learnings and decisions
- Hotspot files (frequently modified, high failure rate)
- Recent failures and postmortems
- **Pending handoffs** (tasks waiting to be picked up)
- Project structure (rooms and entry points)

**Why:** This single call replaces session_start + brief + explore_rooms. It tracks your work, prevents conflicts, and gives you full context immediately.

### 1b. (Alternative) Resume Previous Session

If continuing previous work:

```typescript
const resumed = await session_resume({
  sessionId: "sess_abc123"  // Or use agentType to find latest
})
```

**Why:** Picks up where you left off with full context restoration.

### 3. Explore Codebase (üü¢ RECOMMENDED)

```typescript
// Find relevant code
const results = await explore({intent: "jwt authentication"})

// Get room context
const rooms = await explore_rooms()  // ["api", "auth", "database"]
const authContext = await explore_context({room: "auth"})

// Understand dependencies
const impact = await explore_impact({path: "auth/jwt.ts"})
const callers = await explore_callers({
  symbol: "validateToken",
  file: "auth/jwt.ts"
})
```

**Why:** Understand codebase structure before making changes.

### 4. Recall Existing Knowledge (üü¢ RECOMMENDED)

```typescript
// Check for related learnings
const learnings = await recall({query: "jwt authentication"})

// Check for active decisions
const decisions = await recall_decisions({
  query: "token validation",
  status: "active"
})

// Learn from past failures
const postmortems = await get_postmortems({severity: "high"})
```

**Why:** Avoid repeating past mistakes. Leverage existing knowledge.

### 5. Get File Context (üî¥ CRITICAL - BEFORE EVERY EDIT)

```typescript
const context = await context_auto_inject({file_path: "auth/jwt.ts"})
```

**Returns prioritized context:**
- File-scoped learnings ("never use X in this file")
- File-scoped decisions ("this file must use Y pattern")  
- Failure warnings ("this breaks 40% of the time")
- Edit history (who changed it, when, why)
- Related learnings from room/palace scopes

**Why:** This is non-negotiable. Editing without file context is like performing surgery without reading the patient's chart.

### 6. Check for Conflicts (üü° IMPORTANT)

```typescript
const conflict = await session_conflict({path: "auth/jwt.ts"})
if (conflict.has_conflict) {
  console.log(`${conflict.agent_name} is already editing this file`)
  // Coordinate or wait
}
```

**Why:** Prevents merge conflicts and wasted work.

### 7. Make Changes

Now you have full context. Edit the file safely.

### 8. Log Activity (üü° IMPORTANT)

```typescript
await session_log({
  activity: "file_edit",
  path: "auth/jwt.ts",
  description: "Added refresh token validation logic"
})
```

**Why:** Creates audit trail. Enables session analysis.

### 9. Store Knowledge (üü° IMPORTANT)

```typescript
// Store learnings
await store({
  content: "JWT refresh tokens should expire in 7 days, access tokens in 1 hour",
  as: "decision",
  scope: "room",
  scopePath: "auth",
  rationale: "Balance security (short access tokens) with UX (longer refresh)"
})

// Store learnings from solving problems
await store({
  content: "JWT signature validation must happen before expiration check to prevent timing attacks",
  as: "learning",
  scope: "file",
  scopePath: "auth/jwt.ts"
})
```

**Why:** Builds institutional knowledge. Future agents (or you) can recall this.

### 10. End Session (üî¥ CRITICAL)

```typescript
await session_end({
  outcome: "success",
  summary: "Added JWT refresh token support with proper validation and expiration handling"
})
```

**Why:** Releases locks, marks task complete, enables session analysis.

## Failure Handling: Postmortems

When things go wrong, create a postmortem:

```typescript
await store_postmortem({
  title: "JWT signature bypass vulnerability",
  what_happened: "Expired tokens were accepted due to wrong validation order",
  root_cause: "Checked expiration before signature, allowing signature replay attacks",
  lessons_learned: [
    "Always validate signature first",
    "Add integration tests for expired tokens",
    "Review security checklist before auth changes"
  ],
  prevention_steps: [
    "Reorder validation: signature ‚Üí expiration ‚Üí claims",
    "Add test: test_expired_token_rejection()",
    "Add pre-commit hook for auth file changes"
  ],
  severity: "critical",
  affected_files: ["auth/jwt.ts", "middleware/authenticate.ts"],
  related_decision: "d_abc123"
})

// Extract learnings from postmortem
await postmortem_to_learnings({postmortemId: "pm_xyz789"})
```

This prevents repeating the same mistake.

## Scope Hierarchy

Knowledge has four scope levels (most specific wins):

1. **File**: `scope: "file", scopePath: "auth/jwt.ts"`
   - "This specific file should never import from parent directories"

2. **Room**: `scope: "room", scopePath: "auth"`
   - "All auth files must use bcrypt for password hashing"

3. **Palace** (workspace): `scope: "palace"`
   - "Use TypeScript strict mode across entire project"

4. **Corridor** (personal/global): Requires explicit promotion
   - "Always validate input at API boundaries" (applies to all your projects)

When storing knowledge, choose the narrowest applicable scope.

## Context Management

### Set Task Focus

Focus context retrieval on your current task:

```typescript
await context_focus({
  task: "Implement rate limiting for API endpoints",
  pin: ["l_ratelimit123", "d_api456"]  // Pin specific records
})
```

Now all context retrievals will prioritize rate-limiting related knowledge.

### Get Focused Context

```typescript
const context = await context_get({
  file: "api/middleware.ts",  // Optional: file-specific
  maxTokens: 2000
})
```

Returns prioritized learnings, pinned records, active decisions, and warnings.

### Pin Important Records

```typescript
// Pin a crucial learning for this session
await context_pin({id: "l_important123"})

// Unpin when no longer needed
await context_pin({id: "l_important123", unpin: true})
```

---

## Multi-Agent Handoffs

### Create a Handoff

When you can't complete a task, hand it off:

```typescript
await handoff_create({
  task: "Complete API rate limiting implementation",
  to: "claude-code",  // Or "any" for any agent
  context: "Started implementing token bucket algorithm. Redis backend configured.",
  pending: [
    "Add rate limit headers to responses",
    "Implement per-user limits",
    "Add monitoring dashboard"
  ],
  pin: ["l_ratelimit123"],  // Include relevant learnings
  priority: "high"
})
```

### Check for Pending Handoffs

```typescript
const handoffs = await handoff_list({status: "pending"})
```

**Note:** `session_init` automatically shows pending handoffs at session start.

### Accept a Handoff

```typescript
const handoff = await handoff_accept({id: "hoff_12345678"})
// Automatically sets your context focus to the handoff task
// Pins the handoff's records to your context
```

### Complete a Handoff

```typescript
await handoff_complete({
  id: "hoff_12345678",
  summary: "Implemented all rate limiting features with Redis backend"
})
```

---

## Analytics & Health

### Check Workspace Health

```typescript
const health = await analytics_health()
// Returns: health score (0-100), knowledge health, contradictions,
// session success rates, failure tracking, handoff status
```

### Session Analytics

```typescript
const stats = await analytics_sessions({days: 30})
// Returns: session counts, completion rates, average duration,
// activity outcomes, agent breakdown
```

### Learning Effectiveness

```typescript
const effectiveness = await analytics_learnings({
  limit: 20,
  sort: "use_count"  // or "confidence" or "combined"
})
// Shows which learnings are most used and effective
```

---

## Advanced Features

### Semantic Search (if embeddings configured)

```typescript
// Conceptual search - finds related concepts even without keyword match
await search_semantic({query: "retry logic with exponential backoff"})

// Hybrid: keyword + semantic (best of both)
await search_hybrid({query: "error handling"})

// Find similar records
await search_similar({recordId: "l_abc123"})
```

### Contradiction Detection

```typescript
// Find contradicting records
await recall_contradictions({recordId: "l_abc123"})

// Check if two records contradict
await recall_contradiction_check({
  record1Id: "l_abc123",
  record2Id: "d_xyz789"
})
```

### Decay Management

```typescript
// Preview what would decay
await decay_preview()

// Apply decay (reduces confidence of unused learnings)
// NEVER do this without preview + user approval
await decay_apply()
```

### Learning Lifecycle

```typescript
// Link learning to decision for automatic feedback
await recall_learning_link({
  decisionId: "d_abc123",
  learningId: "l_xyz789"
})
// Now when decision outcome is recorded, learning confidence auto-updates

// Record decision outcome
await recall_outcome({
  decisionId: "d_abc123",
  outcome: "success",
  note: "Reduced DB queries by 60%, no issues in production"
})

// Mark learning as obsolete
await recall_obsolete({
  learningId: "l_old123",
  reason: "Superseded by new approach using Redis caching"
})
```

### Corridor (Cross-Workspace Knowledge)

```typescript
// Get personal learnings from all your projects
await corridor_learnings({query: "error handling"})

// Promote workspace learning to personal corridor
await corridor_promote({learningId: "l_abc123"})
// Now this learning follows you to every project

// Reinforce corridor learning when it helps
await corridor_reinforce({learningId: "l_corridor456"})
```

## Anti-Patterns (Don't Do This)

‚ùå Start work without `session_start`  
‚ùå Edit files without `context_auto_inject`  
‚ùå Forget to call `session_end`  
‚ùå Work without calling `brief` first  
‚ùå Ignore `session_conflict` warnings  
‚ùå Store vague learnings ("this is good" - too generic)  
‚ùå Never log activities (breaks audit trail)  
‚ùå Apply decay without preview + approval  

## Best Practices

‚úÖ Start with `session_start`, `brief`  
‚úÖ Get context before every file edit  
‚úÖ Check conflicts before editing  
‚úÖ Store specific, actionable learnings  
‚úÖ Log major activities  
‚úÖ End session when done  
‚úÖ Learn from postmortems  
‚úÖ Use explore tools to understand codebase  
‚úÖ Check decisions before implementing  
‚úÖ Choose appropriate scope for knowledge  

## Configuration for Agents

Mind Palace provides preset rules files for all major AI coding tools. When you install MCP configuration, the appropriate rules file is automatically copied to your workspace.

### Supported Tools

| Tool | Rule File | Command |
|------|-----------|---------|
| Claude Code | `CLAUDE.md` | `palace mcp-config --for claude-code --install` |
| Cursor | `.cursorrules` | `palace mcp-config --for cursor --install` |
| Windsurf | `.windsurfrules` | `palace mcp-config --for windsurf --install` |
| VS Code Copilot | `.github/copilot-instructions.md` | `palace mcp-config --for vscode --install` |
| Gemini CLI | `GEMINI.md` | `palace mcp-config --for gemini-cli --install` |
| Claude Desktop | `globalRules` in config | `palace mcp-config --for claude-desktop --install` |

### Example: Setting Up Claude Code

```sh
# Initialize Mind Palace in your project
palace init
palace scan

# Install MCP config and agent rules
palace mcp-config --for claude-code --install
```

This creates:
- `.mcp.json` - MCP server configuration
- `CLAUDE.md` - Agent rules file with autonomous workflow instructions

### Example: Setting Up Cursor

```sh
palace mcp-config --for cursor --install
```

This creates:
- `~/.cursor/mcp.json` - MCP server configuration
- `.cursorrules` - Agent rules file in your workspace

See the [Agent Rules Reference](/reference/agent-rules) for complete documentation on customizing rules for your team.

## Tool Categories

Mind Palace has 77+ tools across 13 categories:

1. **Composite** (1 tool): `session_init` - single-call initialization
2. **Explore** (12 tools): Search codebase, find symbols, analyze impact
3. **Session** (9 tools): Session management, logging, conflict detection, resume, status
4. **Store** (4 tools): Store ideas, decisions, learnings
5. **Recall** (12 tools): Retrieve knowledge, check outcomes, manage links
6. **Brief** (4 tools): Get briefings, file intelligence, smart analysis
7. **Context** (3 tools): Task focus, prioritized context, pinning
8. **Handoff** (4 tools): Multi-agent task handoff and coordination
9. **Analytics** (3 tools): Session stats, learning effectiveness, health dashboard
10. **Conversation** (3 tools): Store/search conversations, extract insights
11. **Corridor** (5 tools): Cross-workspace personal knowledge
12. **Postmortem** (5 tools): Failure documentation and learning
13. **Learning Lifecycle** (8 tools): Decay, obsolescence, archival
14. **Advanced** (4 tools): Semantic search, contradiction detection, embeddings

See the [API Reference](/reference/mcp-tools) for complete tool documentation.

## Example: Complete Feature Implementation

```typescript
// 1. Initialize (single call replaces session_start + brief + explore_rooms)
const init = await session_init({
  agent_name: "claude",
  task: "Add rate limiting to API"
})
// Check init.pendingHandoffs for any waiting tasks

// 2. Explore
const apiFiles = await explore_context({room: "api"})
const rateLimitCode = await explore({intent: "rate limiting middleware"})

// 3. Recall Knowledge
const learnings = await recall({query: "rate limiting"})
const decisions = await recall_decisions({query: "api security", status: "active"})
const failures = await get_postmortems({severity: "high"})

// 4. Get File Context
const context = await context_auto_inject({file_path: "api/middleware/rateLimit.ts"})

// 5. Check Conflicts
await session_conflict({path: "api/middleware/rateLimit.ts"})

// 6. Make Changes
// [Edit file with full context]

// 7. Log Activity
await session_log({
  activity: "file_edit",
  path: "api/middleware/rateLimit.ts",
  description: "Implemented token bucket rate limiting"
})

// 8. Store Knowledge
await store({
  content: "Use token bucket algorithm for API rate limiting - allows bursts while maintaining average rate",
  as: "decision",
  scope: "room",
  scopePath: "api",
  rationale: "More flexible than fixed window, prevents thundering herd"
})

await store({
  content: "Rate limit counters should use Redis with TTL, not in-memory - enables multi-instance deployment",
  as: "learning",
  scope: "file",
  scopePath: "api/middleware/rateLimit.ts"
})

// 9. End Session
await session_end({
  outcome: "success",
  summary: "Implemented token bucket rate limiting with Redis backend"
})
```

## FAQ

**Q: Should I use session_init or session_start?**
A: Use `session_init` - it's a single call that combines session_start + brief + explore_rooms and shows pending handoffs.

**Q: Can I skip context_auto_inject if I'm making a small change?**
A: No. Small changes can have big impacts. Always get file context.

**Q: When should I store knowledge?**
A: After solving problems, making decisions, or discovering patterns. Be specific and actionable.

**Q: What's the difference between learning and decision?**
A: Decisions are choices with rationale. Learnings are observations or patterns. Ideas are proposals.

**Q: Should I use semantic search or keyword search?**
A: Use `explore` (keyword) first. Use `search_semantic` or `search_hybrid` for conceptual queries if embeddings are configured.

**Q: How do I handle multi-agent scenarios?**
A: `session_init` shows active agents. Use `session_conflict()` before editing. Use handoffs to pass work between agents.

**Q: What if I can't complete a task?**
A: Create a handoff with `handoff_create` including context, pending items, and relevant learnings. Another agent can pick it up.

**Q: How do I continue work from a previous session?**
A: Use `session_resume({sessionId: "..."})` or `session_resume({agentType: "..."})` to find and resume the latest session.

**Q: What if I forget to call session_end?**
A: Session persists as "active", potentially blocking other agents. Always end sessions.

**Q: How do I check workspace health?**
A: Call `analytics_health()` for an overall health score and issue list. Good practice at session start.

**Q: Can I use Mind Palace without autonomous features?**
A: Yes, but you miss the point. Mind Palace is designed for autonomous agent workflows.

## Next Steps

1. Run `palace mcp-config --for <your-agent> --install`
2. Read the `.cursorrules` or `globalRules` in your config  
3. Start using the 3-step workflow: session ‚Üí brief ‚Üí context ‚Üí work ‚Üí end
4. Store knowledge as you work
5. Learn from postmortems

See [API Reference](/reference/mcp-tools) for complete tool documentation.
